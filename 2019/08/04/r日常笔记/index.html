<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="字符串String 内容不可变字符串，底层用了不可变数组 final char []实现StringBuffer(线程安全)， StringBuild（线程不安全，效率高） 可变字符串， char [] 集合集合分为存储值(collection)，和key-value(map)值：List Set        List 有序 可重复        ArrayList  底层数组实现 ，具有索引，">
<meta property="og:type" content="article">
<meta property="og:title" content="日常笔记">
<meta property="og:url" content="https://github.com/fanyahui/fanyahui.github.io/2019/08/04/r日常笔记/index.html">
<meta property="og:site_name" content="吾日三省吾身">
<meta property="og:description" content="字符串String 内容不可变字符串，底层用了不可变数组 final char []实现StringBuffer(线程安全)， StringBuild（线程不安全，效率高） 可变字符串， char [] 集合集合分为存储值(collection)，和key-value(map)值：List Set        List 有序 可重复        ArrayList  底层数组实现 ，具有索引，">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-07T09:21:11.413Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="日常笔记">
<meta name="twitter:description" content="字符串String 内容不可变字符串，底层用了不可变数组 final char []实现StringBuffer(线程安全)， StringBuild（线程不安全，效率高） 可变字符串， char [] 集合集合分为存储值(collection)，和key-value(map)值：List Set        List 有序 可重复        ArrayList  底层数组实现 ，具有索引，">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/fanyahui/fanyahui.github.io/2019/08/04/r日常笔记/">





  <title>日常笔记 | 吾日三省吾身</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">吾日三省吾身</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/fanyahui/fanyahui.github.io/2019/08/04/r日常笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.fan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吾日三省吾身">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">日常笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-04T21:13:25+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>String 内容不可变字符串，底层用了不可变数组 final char []实现<br>StringBuffer(线程安全)， StringBuild（线程不安全，效率高） 可变字符串， char []</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合分为存储值(collection)，和key-value(map)<br>值：List Set<br>        List 有序 可重复<br>        ArrayList  底层数组实现 ，具有索引，查询特定元素快，插入和删除慢（数组在内存中是连续的内存，删除和插入需要移动内存）<br>        LinkedList 底层使用链表，查询时从头部开始一个一个便利索引，查询效率低，插入是不需要移动内存，只需要改变引用指向即可，所以插入删除效率高。<br>        Set 无序 不可重复 ，根据hashcode和equals 方法判断<br>HashMap —- HashTable<br>都存储 key-value ,<br>1：HashMap可以存null，key或value,HashTable不可以<br>2:  HashMap线程不安全，效率高，HashTable 线程安全，效率低<br>CurrentHashMap 线程安全，效率高。<br>原理：（把大的Map分割成N个小的Map–Segment,类似HashTable,给各个小的Map加锁，第一个Map的数据加锁时，不影响第二个Map的使用，使效率提升，默认提升16倍。）</p>
<h3 id="字节流，字符流"><a href="#字节流，字符流" class="headerlink" title="字节流，字符流"></a>字节流，字符流</h3><p>字符流传递的是字符，中文汉字<br>字节流传输的是二进制的字节。<br>传输的文件比一定包含字符，有可能包含字节，比如，图片，音频，图像，为了考虑通用性，使用字节流</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>实现方式：<br>1:继承Thread类<br>2:实现Runnable接口<br>java 是单继承，多实现，所以实现Runnable扩展好<br>启动：<br>Thread thread = new Thread(继承Thread的对象，或者实现Runnable的对象);<br>thread.start();<br>注意：不要用字符串常量加锁，容易产生死锁。<br><strong>synchronized</strong>: 加载方法上，锁的是this，如果方法是static，锁定的是class对象，如果在执行方法是报了异常，虚拟机会自动释放锁。加锁的对象，如果对象属性改变，不影响锁的使用，如果对象的引用变了，则锁的对象发生改变，所以，synchronized锁的是堆内存的对象。保证原子性，可见性<br><strong>volatile</strong>: 解决线程之间的可见性，A,B线程都读取同一个值时，如果B线程修改了值，A线程是无感知的，加上volatile时，主线程修改了值后，会强制所有线程都去重新读取值；<br>保证可见性，但不保证原子性；<br>++i 操作不保证原子性。<br><strong>Atomic</strong>：简单的增加或修改数值，可以用AtomicXXX类保证原子性问题，如：（AtomicInteger,AtomicLong）<br>AtomicInteger a = new AtomicInteger(0);<br>a.incrementAndGet();  // 这个方法是替代 ++i，保证原子性<br>if(a.count() &lt; 1000){<br>//中间不具备原子性<br>    a.incrementAndGet();<br>}
wait(释放锁),object.wait(),object对象上的该线程进行等待，释放锁，其他线程可以获取object对象的锁<br>notify(不释放锁) 叫醒 object上等待的某个线程，notifyAll 唤醒所有等待线程<br>sleep(不释放锁)</p>
<p>测试题：两个线程，第一个线程一个自增到10，第二个线程监控，如果加到5就结束第二个线程，第一个继续往下走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yahui.fan.zookeeper.ThreadTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  两个线程，第一个线程一个自增到10，第二个线程监控，如果加到5就结束第二个线程，第一个继续往下走。</span></span><br><span class="line"><span class="comment"> *  第一种方式，用wai(),notify(),进行线程通信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; i = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer o)</span></span>&#123;</span><br><span class="line">        i.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Integer <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"T2启动。。"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"不等于5，T2等待，释放锁"</span>);</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"T2结束"</span>);</span><br><span class="line">                System.out.println(<span class="string">"T2结束，释放锁，T1继续执行"</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"T1启动。。"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    i.add(j);</span><br><span class="line">                    System.out.println(<span class="string">"add:"</span>+ j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"等于5，唤醒T2"</span>);</span><br><span class="line">                        object.notify();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"释放T1当前的锁，让T2执行"</span>);</span><br><span class="line">                            object.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"T1结束。。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>T2启动。。<br>不等于5，T2等待，释放锁<br>T1启动。。<br>add:1<br>add:2<br>add:3<br>add:4<br>add:5<br>等于5，唤醒T2<br>释放T1当前的锁，让T2执行<br>T2结束<br>T2结束，释放锁，T1继续执行<br>add:6<br>add:7<br>add:8<br>add:9<br>add:10<br>T1结束。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yahui.fan.zookeeper.ThreadTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  两个线程，第一个线程一个自增到10，第二个线程监控，如果加到5就结束第二个线程，第一个继续往下走。</span></span><br><span class="line"><span class="comment"> *  第二种方式，CountDownLatch计数器实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; i = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer o)</span></span>&#123;</span><br><span class="line">        i.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Integer <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"T2开始"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i.size() != <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"长度不等于5，计数器等待，T2等待。"</span>);</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"T2结束。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"T1开始"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                i.add(j);</span><br><span class="line">                System.out.println(<span class="string">"add:"</span> + j);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"长度等于5，计数器减一，唤醒T2线程"</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"T1结束"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>T2开始<br>长度不等于5，计数器等待，T2等待。<br>T1开始<br>add:1<br>add:2<br>add:3<br>add:4<br>add:5<br>长度等于5，计数器减一，唤醒T2线程<br>T2结束。<br>add:6<br>add:7<br>add:8<br>add:9<br>add:10<br>T1结束<br><strong>总结：</strong>         两种方式，第二种比较简单易懂，CountDownLatch 不需要对象锁，易扩展，没有像第一个种方式重复的释放锁，执行，过程，效率较高</p>
<p>ReentranLock 必须手动释放锁<br>tryLock()  尝试获取锁，可指定时间，获取不到锁返回false<br>ReentranLock lock = new ReentranLock() –非公平锁 性能高<br>ReentranLock lock = new ReentranLock(true); –公平锁，等待时间长的线程先执行，性能低<br>wait方法一般搭配while使用，不要用if<br>在多线程生产消费模式下，唤醒线程用notifyAll(),不要用notify(),可能会造成死锁</p>
<h4 id="实现一个容器，使用生产者消费者进行容器消费，容器总容量为10"><a href="#实现一个容器，使用生产者消费者进行容器消费，容器总容量为10" class="headerlink" title="实现一个容器，使用生产者消费者进行容器消费，容器总容量为10."></a>实现一个容器，使用生产者消费者进行容器消费，容器总容量为10.</h4><h4 id="第一种方式实现：-利用Codition-和-Lock-实现，Condition可以等待，唤醒一部分线程"><a href="#第一种方式实现：-利用Codition-和-Lock-实现，Condition可以等待，唤醒一部分线程" class="headerlink" title="第一种方式实现： 利用Codition 和 Lock 实现，Condition可以等待，唤醒一部分线程"></a>第一种方式实现： 利用Codition 和 Lock 实现，Condition可以等待，唤醒一部分线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">// 容器最大容量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Integer MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * while 和wait 结合一起用，为什么不用不用if判断？</span></span><br><span class="line"><span class="comment">         * 如果用if，容器到最大后，进行wait等待，这时，如果消费者消费了一个，然后同时唤醒两个生产者线程</span></span><br><span class="line"><span class="comment">         * 两个生产者被唤醒，在linkedList.add(t) 的时候，只要一个线程增加进去。另外一个线程在增加就会出现问题</span></span><br><span class="line"><span class="comment">         * 用while，当生产者被唤醒的时候，会在判断一次count == MAX，才会继续往下进行</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX) &#123;</span><br><span class="line">            <span class="comment">//如果容器达到最大值，生产者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"生产，当前容器："</span>+linkedList.size());</span><br><span class="line">        linkedList.add(t);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里为什么用notifyAll 不用nitify?</span></span><br><span class="line"><span class="comment">         * 如果用nitify,容器满了之后，如果唤醒的还是生产者线程，调用wait,就造成了线程死锁。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> T <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (linkedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果容器为空，消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费，当前容器："</span>+linkedList.size());</span><br><span class="line">        t = linkedList.removeFirst();</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadTest3&lt;String&gt; threadTest3 = <span class="keyword">new</span> ThreadTest3();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    System.out.println(threadTest3.consumer());</span><br><span class="line">            &#125;,<span class="string">"c"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    threadTest3.producer(Thread.currentThread().getName()+<span class="string">""</span>);</span><br><span class="line">            &#125;,<span class="string">"p"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种方式实现：-利用Codition-和-Lock-实现，Condition可以等待，唤醒一部分线程"><a href="#第二种方式实现：-利用Codition-和-Lock-实现，Condition可以等待，唤醒一部分线程" class="headerlink" title="第二种方式实现： 利用Codition 和 Lock 实现，Condition可以等待，唤醒一部分线程"></a>第二种方式实现： 利用Codition 和 Lock 实现，Condition可以等待，唤醒一部分线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yahui.fan.zookeeper.ThreadTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest4</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="comment">// 容器最大容量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Integer MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             <span class="keyword">while</span> (count == MAX) &#123;</span><br><span class="line">                 <span class="comment">//如果容器达到最大值，生产者等待</span></span><br><span class="line">                 producer.await();</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="string">"生产，当前容器："</span>+linkedList.size());</span><br><span class="line">             linkedList.add(t);</span><br><span class="line">             ++count;</span><br><span class="line">             <span class="comment">//唤醒所有消费者等待线程</span></span><br><span class="line">             consumer.signal();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function">T <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             <span class="keyword">while</span> (linkedList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//如果容器为空，消费者等待</span></span><br><span class="line">                 consumer.await();</span><br><span class="line">             &#125;</span><br><span class="line">             System.out.println(<span class="string">"消费，当前容器："</span>+linkedList.size());</span><br><span class="line">             t = linkedList.removeFirst();</span><br><span class="line">             count--;</span><br><span class="line">             <span class="comment">//唤醒所有生产者</span></span><br><span class="line">             producer.signalAll();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadTest4&lt;String&gt; threadTest4 = <span class="keyword">new</span> ThreadTest4();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    System.out.println(threadTest4.consumer());</span><br><span class="line">            &#125;,<span class="string">"c"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    threadTest4.producer(Thread.currentThread().getName()+<span class="string">""</span>);</span><br><span class="line">            &#125;,<span class="string">"p"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThrealLoacl-当前线程会复制一个变量副本，每个线程互不影响，synchronized-是一个线程完了之后另一个才可以执行，所以，ThreadLocal是空间换时间，synchronized是时间换空间"><a href="#ThrealLoacl-当前线程会复制一个变量副本，每个线程互不影响，synchronized-是一个线程完了之后另一个才可以执行，所以，ThreadLocal是空间换时间，synchronized是时间换空间" class="headerlink" title="ThrealLoacl 当前线程会复制一个变量副本，每个线程互不影响，synchronized 是一个线程完了之后另一个才可以执行，所以，ThreadLocal是空间换时间，synchronized是时间换空间"></a>ThrealLoacl 当前线程会复制一个变量副本，每个线程互不影响，synchronized 是一个线程完了之后另一个才可以执行，所以，ThreadLocal是空间换时间，synchronized是时间换空间</h4><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>map,set的使用<br>不同步，不加锁:<br>HashMap<br>TreeMap<br>HashSet<br>LinkedHashMap<br>同步，加锁：<br>并发不高:HashTable,Collections.synchronizeXXX.<br>并发高:ConcurrentHashMap<br>高并发，顺序:ConcurrentSkipListMap</p>
<p>ConcurrentHashMap  分为16个小的Map,分段加锁，性能高</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>1:高并发，内部加锁 – ConcurrentLinkedQueue 单向队列<br>    offer() 增加，无界队列，如果内存够，一直可以加<br>    poll() 取出第一个并删除<br>    peek() 取出第一个，不删除<br>2:高并发，阻塞 LinkedBlockingQueue，ArrayBlockingQueue<br>    put() 存，如果队列满了，阻塞等待<br>    take() 取，如果队列空了，阻塞等待<br>    代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yahui.fan.zookeeper.QueueTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.jvm.hotspot.opto.Block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 LinkedBlockingQueue 实现生产消费队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 无界队列，只要内存够，一直可以put</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞队列</span></span><br><span class="line">     <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="string">"pro:"</span>+i);<span class="comment">//如果队列满了，就会阻塞，</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"producer"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"-"</span>+<span class="string">"con-"</span>+queue.take()); <span class="comment">//take 如果队列空了，阻塞</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">"consumer"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3: ArrayBlockingQueue 有界队列<br>// 队列里边只能装10个<br>BlockingQueue queue  = new ArrayBlockingQueue(10);<br>queue.add(“i”); //容器满了会报异常<br>queue.offer(“i”); //容器满了不保异常，根据返回值判断是否添加成功<br>queue.offer(“i”;TimeUnit.SECONDS); 隔一段时间添加，加不进去，终止<br>queue.put(“i”);  容器满了，阻塞等待<br>4: DelayQueue 无界队列，定时队列，等待时间最长先出<br>BlockingQueue queue  = new DelayQueue();<br>5: LinkedTransferQueue 如果消费者等待，那生产者queue任务到了不直接扔到队列，而是直接给了消费者queue<br>LinkdeTransferQueue queue = new LinkedTransferQueue();<br>queue.transfer(“a”);//生产的消息必须马上处理，不然阻塞<br>6: SynchronousQueue 同步队列<br>BlockingQueue queue  = new SynchronousQueue();<br>queue.add(“”);//如果没有消费者，报错<br>queue.put(“”);//如果没有消费者，阻塞</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Executor<br>Executors  工具类<br>ExecutorService  -submit(Runnable/Callable)  -execute(Runnable)<br>Runnable 没有返回值<br>Callable 有返回值，可以抛异常</p>
<h4 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yahui.fan.zookeeper.ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(executorService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池，等待所有线程都结束关闭</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 直接关闭线程池,不等待线程</span></span><br><span class="line">        <span class="comment">//executorService.shutdownNow();</span></span><br><span class="line">        <span class="comment">//线程池的所有任务是否全部执行完毕</span></span><br><span class="line">        System.out.println(executorService.isTerminated());</span><br><span class="line">        <span class="comment">//线程池是否关闭</span></span><br><span class="line">        System.out.println(executorService.isShutdown());</span><br><span class="line">        System.out.println(executorService);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(executorService.isTerminated());</span><br><span class="line">        System.out.println(executorService.isShutdown());</span><br><span class="line">        System.out.println(executorService);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br>//queued tasks = 1  一个等待任务<br>java.util.concurrent.ThreadPoolExecutor@46ee7fe8[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]<br>false<br>true<br>java.util.concurrent.ThreadPoolExecutor@46ee7fe8[Shutting down, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]<br>pool-1-thread-2<br>pool-1-thread-3<br>pool-1-thread-4<br>pool-1-thread-5<br>pool-1-thread-1<br>pool-1-thread-2<br>true<br>true<br>//线程池正常关闭，已执行任务列表<br>java.util.concurrent.ThreadPoolExecutor@46ee7fe8[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 6]</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yahui.fan.zookeeper.ThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Future 多线程计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool_02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单线程计算</span></span><br><span class="line">        <span class="keyword">long</span> l2 = System.currentTimeMillis();</span><br><span class="line">        List&lt;Integer&gt; prime = getPrime(<span class="number">1</span>, <span class="number">200000</span>);</span><br><span class="line">        <span class="keyword">long</span> l3 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(l3-l2);</span><br><span class="line">        System.out.println(prime.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//多线程计算</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; submit = executorService.submit(<span class="keyword">new</span> MyTask(<span class="number">1</span>, <span class="number">60000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; submit1 = executorService.submit(<span class="keyword">new</span> MyTask(<span class="number">60001</span>, <span class="number">100000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; submit2 = executorService.submit(<span class="keyword">new</span> MyTask(<span class="number">100001</span>, <span class="number">140000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; submit3 = executorService.submit(<span class="keyword">new</span> MyTask(<span class="number">140001</span>, <span class="number">180000</span>));</span><br><span class="line">        Future&lt;List&lt;Integer&gt;&gt; submit4 = executorService.submit(<span class="keyword">new</span> MyTask(<span class="number">180001</span>, <span class="number">200000</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">            List&lt;Integer&gt; all = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; integers = submit.get();</span><br><span class="line">            List&lt;Integer&gt; integers1 = submit1.get();</span><br><span class="line">            List&lt;Integer&gt; integers2 = submit2.get();</span><br><span class="line">            List&lt;Integer&gt; integers3 = submit3.get();</span><br><span class="line">            List&lt;Integer&gt; integers4 = submit4.get();</span><br><span class="line">            all.addAll(integers);</span><br><span class="line">            all.addAll(integers1);</span><br><span class="line">            all.addAll(integers2);</span><br><span class="line">            all.addAll(integers3);</span><br><span class="line">            all.addAll(integers4);</span><br><span class="line">            <span class="keyword">long</span> l1 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(l1-l);</span><br><span class="line">            System.out.println(all.size());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start, end;</span><br><span class="line">        MyTask(<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPrime(start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= num/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num%<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i)) list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br>19<br>100001<br>3
100001</p>
<h4 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h4><p>//固定个数线程池<br>–1 ExecutorService executorService = Executors.newFixedThreadPool(5);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">                                                         <span class="comment">//指定线程池大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                       <span class="comment">//线程存活时间，永远存在</span></span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">									  <span class="comment">//无界阻塞队列</span></span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>//缓存线程池，启动时池中没有线程，有任务过来，就创建，释放的就在线程池中缓存，下个任务来了继续用，如果一直没有任务用，默认60s自动关闭该线程<br>–2 ExecutorService executorService1 = Executors.newCachedThreadPool();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">															<span class="comment">//初始线程为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">										<span class="comment">// 有效时间默认60秒</span></span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>// 单例线程池 只有一个线程的线程池，可以保证扔到线程池里的任务是顺序执行<br>–3 ExecutorService executorService2 = Executors.newSingleThreadExecutor();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">		<span class="comment">//默认只有并且最大线程数只有一个</span></span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">								<span class="comment">//永远存活</span></span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>// 定时执行<br>–4 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(4);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay, <span class="comment">//第一个线程各多长时间开始执行</span></span><br><span class="line">                                                  <span class="keyword">long</span> period,	<span class="comment">//每个线程各多久执行</span></span><br><span class="line">                                                  TimeUnit unit);	<span class="comment">//时间单位</span></span><br><span class="line">												  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"><span class="comment">//指定大小，永远存活，使用定时队列</span></span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>// 精灵线程，每个线程维护自己的队列，自己队列没有任务时，会执行别的线程队列里的任务<br>–5 ExecutorService executorService1 = Executors.newWorkStealingPool();<br>        默认会根据当前机器的线程来启动相应数量的线程<br>        //查看本机线程数<br>        System.out.println(Runtime.getRuntime().availableProcessors());<br>// 当任务特别大时，分成多个小线程执行，最后在合并结果<br>–6 ForkJoinPool forkJoinPool = new ForkJoinPool();</p>
<p>—- 1，2，3，4种线程最终都返回 ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p>备注： java8 stream提供多线程计算 parallelStream()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; all = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">all.parallelStream().count();</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/02/zookeeper分布式锁/" rel="next" title="zookeeper分布式锁">
                <i class="fa fa-chevron-left"></i> zookeeper分布式锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/06/责任链模式-Spring-AOP/" rel="prev" title="责任链模式--Spring-AOP">
                责任链模式--Spring-AOP <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Mr.fan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">2.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流，字符流"><span class="nav-number">3.</span> <span class="nav-text">字节流，字符流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">4.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现一个容器，使用生产者消费者进行容器消费，容器总容量为10"><span class="nav-number">4.1.</span> <span class="nav-text">实现一个容器，使用生产者消费者进行容器消费，容器总容量为10.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第一种方式实现：-利用Codition-和-Lock-实现，Condition可以等待，唤醒一部分线程"><span class="nav-number">4.2.</span> <span class="nav-text">第一种方式实现： 利用Codition 和 Lock 实现，Condition可以等待，唤醒一部分线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二种方式实现：-利用Codition-和-Lock-实现，Condition可以等待，唤醒一部分线程"><span class="nav-number">4.3.</span> <span class="nav-text">第二种方式实现： 利用Codition 和 Lock 实现，Condition可以等待，唤醒一部分线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThrealLoacl-当前线程会复制一个变量副本，每个线程互不影响，synchronized-是一个线程完了之后另一个才可以执行，所以，ThreadLocal是空间换时间，synchronized是时间换空间"><span class="nav-number">4.4.</span> <span class="nav-text">ThrealLoacl 当前线程会复制一个变量副本，每个线程互不影响，synchronized 是一个线程完了之后另一个才可以执行，所以，ThreadLocal是空间换时间，synchronized是时间换空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发容器"><span class="nav-number">5.</span> <span class="nav-text">并发容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-number">6.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">7.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPool"><span class="nav-number">7.1.</span> <span class="nav-text">ThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">7.2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池种类"><span class="nav-number">7.3.</span> <span class="nav-text">线程池种类</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.fan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
